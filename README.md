# Задание
- Необходимо реализовать сервис, выдающий текущий курс валюты 
и историю изменения курса через HTTP REST API, 
с доступом только для авторизованных пользователей.
- Язык php, можно использовать БД MySQL.
- Доп требование:
  - История курсов валют должна быть на каждый день, без пропусков.
  - Объяснить, что нужно добавить или изменить, чтобы сервис мог 
  выдержать 1500 запросов в секунду.
# Как установить
## Предварительные требования
- php 7+
- SQLite 3+
- PHP Composer
## Установка
- клонируем  [этот репозиторий](https://github.com/SbWereWolf/rise.git)
- `composer install`
- у всех *.example файлов удаляем  .example или можно выполнить скрипт:
```cmd
copy .\api\.htaccess.example .\api\.htaccess
copy .\configuration\database.sqlite.example .\configuration\database.sqlite
copy .\configuration\production.php.example .\configuration\production.php
copy .\configuration\salt.php.example .\configuration\salt.php
```
- делаем директорию  `.\api` "публичной" на веб сервере
- все запросы перенаправляем на index.php
- добавляем таблицы для БД
  - `POST http://local.rise/api/v1/storage`
  - код ответа : 
    - успешная операция - `201`, 
    - сбой операции - `500` 
## Опционально
Если очень хочется можно в `.\configuration\salt.php` задать свою соль
# Пример использования
## Общие замечания
Сервис спартанский : при любом сбое бросает пользователя 
с его бедой один а один
## Регистрируем пользователя
```
POST http://local.rise/api/v1/user  
login => логин на ваш выбор
password => пароль на ваш выбор
```
код ответа : успешная операция - `201`, сбой операции - `500` 

## Открываем рабочую сессию
```
POST http://local.rise/api/v1/session  
login => ранее зареганный логин
password => пароль соответствующий логину
```
код ответа : успешная операция - `201`, сбой операции - `500` 

будет возвращен токен сессии, токен записываем в блокнотик
## Делаем запрос ставки обмена
```
GET http://local.rise/api/v1/rate/{date}/{source}/{target}/{token}
date => дата в формате dd.MM.YYYY
source => из какой валюты, трёхбуквенный код валюты
target => в какую валюту, трёхбуквенный код валюты
token => токен сессии из блокнотика
```
код ответа : успешная операция - `200`, 
сбой операции или данные недоступны - `500` 

ПРИМЕР:
`GET http://local.rise/api/v1/rate/11.01.2010/USD/RUB/e5833fb6d372229ebfe3cf439b1b5686`  
в ответ свалиться ставка обмена :
`29.776501086` это то сколько RUB выдадут 
за единицу  USD на 11.01.2010
## Опционально очищаем БД
таблицы будут удалены из БД
```DELETE http://local.rise/api/v1/storage``` 

код ответа : успешная операция - `204`, сбой операции - `500`
# Что сделать что бы было 1500 RPS
- Сначала померить сколько есть, вдруг уже 1500 ?
- Потом посмотреть профиль нагрузки и увидеть где потолок 
CPU / MEM / HDD ?
- Если потолок нашли, то масштабируемся вертикально
 (отодвигаем потолок) насколько хватит финансов
- Если потолок не нашли или финансы не позволяют,
 то пытаемся оптимизировать логику по тому параметру 
 где упёрлись в потолок, или где думаем что упираемся
  - меньше читаем с диска
  - меньше одномоментно храним в оперативной памяти
  - меньше вычисляем на процессоре (сокращаем вычислительную сложность)
- Насколько можем внедряем асинхронность и многопоточность
  конечно первым делом меняем логику : 
   - асихронный запрос в кеше 
   - асинхронный запрос на сервисе,
   - можно выделить три микросервиса
     - один всем `рулит` (принимет запросы, консолидирует 
     и выдаёт данные),
     - другой работает с `кешем`,
     - третий работает с `Сервисом исторических данных`
- Если с логикой ни что не помогает,
 то от кеширования в  SQLite переходим к кешированию в ин-мемори СУБД
  (конечно такая СУБД должна уметь скидывать бэкап 
  в постоянную память что бы при выключении питания,
   данные можно было восстановить)
- Последним этапом масштабируемся в ширину: 
  - ставим балансировщик нагрузки и за ним 1500 машинок с АПИ
 (можно начать с двух и добавлять по одной или по десять машин за раз,
 когда желанные 1500 RPS будут достигнуты, 
 тогда новые машины можно не добавлять)
  - придумываем как синхронизируем кеш между машинами,
  - смотрим какой размер кеша оптимальный 
 (или такой что его увеличение не даёт прироста
 производительности, или такой, что от стоимости его объёма
  не теряется рентабельность)
## Дополнительно
- Спросить совета у сообщества или почитать о том как другие люди
 решали схожие задачи.
